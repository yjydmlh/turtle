# 开发指南

<cite>
**本文档引用的文件**  
- [README.md](file://README.md)
- [requirements.txt](file://requirements.txt)
- [frontend/package.json](file://frontend/package.json)
- [app/main.py](file://app/main.py)
- [test_chan_integration.py](file://test_chan_integration.py)
- [chan.py/README.md](file://chan.py/README.md)
- [frontend/svelte.config.js](file://frontend/svelte.config.js)
- [app/api/v1/endpoints/kline.py](file://app/api/v1/endpoints/kline.py)
- [app/models/kline.py](file://app/models/kline.py)
- [app/schemas/kline.py](file://app/schemas/kline.py)
- [app/crud/kline.py](file://app/crud/kline.py)
- [app/services/kline_aggregator.py](file://app/services/kline_aggregator.py)
- [frontend/src/lib/api.js](file://frontend/src/lib/api.js)
- [frontend/src/lib/components/KLineChart.svelte](file://frontend/src/lib/components/KLineChart.svelte)
</cite>

## 目录

1. [贡献者开发指南](#贡献者开发指南)
2. [开发环境搭建](#开发环境搭建)
3. [代码规范](#代码规范)
4. [添加新功能教程](#添加新功能教程)
5. [测试指南](#测试指南)
6. [工具链与自动化](#工具链与自动化)
7. [Pull Request审查流程](#pull-request审查流程)
8. [附录](#附录)

## 贡献者开发指南

本开发指南旨在为希望为缠论分析系统（Turtle Chan Analysis System）做出贡献的开发者提供全面的指导。系统基于缠中说禅理论，集成了实时数据获取、多时间周期聚合、分型识别、笔段构建等核心功能，为数字货币技术分析提供专业服务。

本指南将详细介绍开发环境的搭建、代码规范、新功能添加的分步教程、测试策略、工具链使用以及Pull Request的审查流程。我们的目标是确保所有贡献者都能遵循统一的标准，提交高质量的代码，共同维护项目的稳定性和可维护性。

系统采用现代化的技术栈，后端使用Python + FastAPI构建高性能异步API服务，前端使用Svelte + TailwindCSS提供现代化的Web界面。数据库采用PostgreSQL + TimescaleDB进行时序数据优化，图表展示使用Lightweight Charts库。

我们欢迎任何形式的贡献，包括但不限于：
- 报告Bug和功能建议
- 修复代码缺陷
- 添加新功能和API端点
- 改进文档和示例
- 优化性能和用户体验

通过遵循本指南，您将能够快速上手项目开发，为项目做出有价值的贡献。

**Section sources**
- [README.md](file://README.md#L1-L508)

## 开发环境搭建

### 基础环境要求

在开始开发之前，请确保您的系统满足以下基础环境要求：

- **Python**: 3.8+ (推荐3.11+以获得最佳性能)
- **Node.js**: 16.0+
- **PostgreSQL**: 12.0+ (推荐) 或 SQLite (用于测试)
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+

### 项目克隆与初始化

首先，克隆项目仓库并初始化子模块：

```bash
git clone https://github.com/your-username/turtle.git
cd turtle

# 初始化Chan模块子模块
git submodule update --init
```

### 后端环境设置

1. **安装Python依赖**：
```bash
pip install -r requirements.txt
```

2. **配置环境变量**：
```bash
cp .env.example .env
# 编辑 .env 文件，配置数据库连接等
```

3. **创建数据库表**：
```bash
python create_tables.py
```

4. **运行集成测试**：
```bash
python test_chan_integration.py
```

### 前端环境设置

1. **进入前端目录**：
```bash
cd frontend
```

2. **安装依赖**：
```bash
npm install
```

3. **开发模式启动**：
```bash
npm run dev
```

4. **构建生产版本**：
```bash
npm run build
```

### 系统启动

系统提供多种启动方式：

1. **快速启动（推荐）**：
```bash
python quick_start.py
```

2. **手动启动**：
```bash
python run.py
```

3. **开发模式**：
```bash
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

### 访问系统

启动成功后，可以通过以下地址访问系统：

- **API文档**: http://localhost:8000/api/v1/docs
- **Web界面**: http://localhost:8000 (如果构建了前端)
- **健康检查**: http://localhost:8000/health

### 数据库配置

系统支持PostgreSQL和SQLite两种数据库：

**PostgreSQL (推荐)**：
```bash
# 安装PostgreSQL
sudo apt-get install postgresql postgresql-contrib  # Ubuntu
brew install postgresql  # macOS

# 创建数据库
sudo -u postgres createdb turtle

# 配置.env文件
DATABASE_URL=postgresql://postgres:your_password@localhost:5432/turtle
```

**SQLite (开发测试)**：
```bash
# 在.env文件中配置
DATABASE_URL=sqlite:///./turtle.db
```

**Section sources**
- [README.md](file://README.md#L509-L1017)

## 代码规范

### Python代码规范

后端代码遵循以下规范：

1. **PEP 8规范**：严格遵守Python PEP 8编码规范
2. **类型提示**：使用type hints提高代码可读性和安全性
3. **文档字符串**：为所有函数、类和模块编写详细的docstring
4. **异常处理**：使用自定义异常类进行错误处理
5. **日志记录**：使用统一的日志记录器进行调试和监控

示例代码结构：
```python
from fastapi import APIRouter, Depends
from app.core.exceptions import create_success_response

router = APIRouter()

@router.get("/new-endpoint")
def new_endpoint():
    """获取新功能数据
    
    Returns:
        dict: 包含成功响应的数据
    """
    return create_success_response(data={"message": "Hello World"})
```

### Svelte前端代码规范

前端代码遵循以下规范：

1. **组件命名**：使用PascalCase命名组件
2. **函数命名**：使用camelCase命名函数
3. **代码格式化**：使用Prettier进行代码格式化
4. **类型检查**：使用TypeScript进行类型检查
5. **样式管理**：使用TailwindCSS进行样式管理

示例组件结构：
```svelte
<!-- src/lib/components/NewComponent.svelte -->
<script>
    import { onMount } from 'svelte';
    
    // 组件逻辑
    let data = [];
    
    onMount(async () => {
        // 初始化逻辑
    });
</script>

<div class="new-component">
    <!-- 组件模板 -->
</div>

<style>
    /* 组件样式 */
    .new-component {
        @apply p-4 border rounded-lg;
    }
</style>
```

### Git提交信息格式

所有Git提交信息必须遵循以下格式：

```bash
# 功能开发
git commit -m "feat: 添加新的分析算法"

# 错误修复
git commit -m "fix: 修复数据获取超时问题"

# 文档更新
git commit -m "docs: 更新API文档"

# 样式调整
git commit -m "style: 调整图表显示样式"

# 代码重构
git commit -m "refactor: 重构K线聚合逻辑"

# 性能优化
git commit -m "perf: 优化数据库查询性能"

# 测试相关
git commit -m "test: 添加单元测试用例"
```

提交信息格式说明：
- **类型**：feat, fix, docs, style, refactor, perf, test等
- **作用域**：可选，用于指定修改的模块
- **描述**：简明扼要地描述修改内容

**Section sources**
- [README.md](file://README.md#L1018-L1167)

## 添加新功能教程

### 添加新API端点

#### 1. 创建新的端点文件

在`app/api/v1/endpoints/`目录下创建新的端点文件：

```python
# app/api/v1/endpoints/new_feature.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.exceptions import create_success_response
from app.api.deps import get_db

router = APIRouter()

@router.get("/new-feature")
def get_new_feature(
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100
):
    """获取新功能数据
    
    Args:
        db: 数据库会话
        skip: 跳过的记录数
        limit: 返回的记录数限制
        
    Returns:
        dict: 包含成功响应的数据
    """
    try:
        # 业务逻辑处理
        data = []
        return create_success_response(data=data)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

#### 2. 注册API路由

在`app/api/v1/api.py`中注册新的路由：

```python
from fastapi import APIRouter
from app.api.v1.endpoints import (
    kline,
    chan_analysis,
    new_feature  # 导入新端点
)

api_router = APIRouter()
api_router.include_router(kline.router, prefix="/kline", tags=["kline"])
api_router.include_router(chan_analysis.router, prefix="/chan", tags=["chan"])
api_router.include_router(new_feature.router, prefix="/new-feature", tags=["new-feature"])  # 注册新路由
```

#### 3. 添加请求参数验证

使用Pydantic模型进行请求参数验证：

```python
# app/schemas/new_feature.py
from pydantic import BaseModel
from typing import Optional

class NewFeatureRequest(BaseModel):
    """新功能请求参数"""
    category: Optional[str] = None
    status: Optional[str] = None
    page: int = 1
    page_size: int = 20

class NewFeatureResponse(BaseModel):
    """新功能响应数据"""
    id: int
    name: str
    value: float
    created_at: str
```

#### 4. 实现业务逻辑

在`app/services/`目录下实现业务逻辑：

```python
# app/services/new_feature.py
from typing import List, Dict
from sqlalchemy.orm import Session

class NewFeatureService:
    """新功能服务类"""
    
    def __init__(self):
        pass
        
    def get_features(self, db: Session, category: str = None) -> List[Dict]:
        """获取功能列表
        
        Args:
            db: 数据库会话
            category: 功能类别
            
        Returns:
            功能列表
        """
        # 实现业务逻辑
        pass
        
    def create_feature(self, db: Session, data: dict) -> Dict:
        """创建新功能
        
        Args:
            db: 数据库会话
            data: 功能数据
            
        Returns:
            创建的功能数据
        """
        # 实现创建逻辑
        pass

# 创建全局实例
new_feature_service = NewFeatureService()
```

### 添加新数据模型

#### 1. 创建新的数据模型

在`app/models/`目录下创建新的数据模型：

```python
# app/models/new_model.py
from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean
from sqlalchemy.sql import func
from app.db.base_class import Base

class NewModel(Base):
    """新功能数据模型"""
    __tablename__ = "new_table"
    
    id = Column(Integer, primary_key=True, index=True, comment="主键ID")
    name = Column(String(100), nullable=False, index=True, comment="名称")
    description = Column(Text, nullable=True, comment="描述")
    status = Column(String(20), default="active", comment="状态")
    is_active = Column(Boolean, default=True, comment="是否激活")
    created_at = Column(DateTime, server_default=func.now(), comment="创建时间")
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now(), comment="更新时间")
```

#### 2. 创建CRUD操作

在`app/crud/`目录下创建CRUD操作：

```python
# app/crud/new_model.py
from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.new_model import NewModel
from app.schemas.new_model import NewModelCreate, NewModelUpdate

class CRUDNewModel:
    """新模型CRUD操作"""
    
    def get(self, db: Session, id: int) -> Optional[NewModel]:
        """根据ID获取记录"""
        return db.query(NewModel).filter(NewModel.id == id).first()
        
    def get_multi(
        self, db: Session, *, skip: int = 0, limit: int = 100
    ) -> List[NewModel]:
        """获取多条记录"""
        return db.query(NewModel).offset(skip).limit(limit).all()
        
    def create(self, db: Session, *, obj_in: NewModelCreate) -> NewModel:
        """创建新记录"""
        db_obj = NewModel(**obj_in.dict())
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj
        
    def update(
        self, db: Session, *, db_obj: NewModel, obj_in: NewModelUpdate
    ) -> NewModel:
        """更新记录"""
        update_data = obj_in.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_obj, field, value)
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj
        
    def remove(self, db: Session, *, id: int) -> NewModel:
        """删除记录"""
        obj = db.query(NewModel).get(id)
        db.delete(obj)
        db.commit()
        return obj

# 创建全局实例
new_model = CRUDNewModel()
```

#### 3. 创建Pydantic模型

在`app/schemas/`目录下创建Pydantic模型：

```python
# app/schemas/new_model.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class NewModelBase(BaseModel):
    """新模型基础模型"""
    name: str
    description: Optional[str] = None
    status: Optional[str] = "active"

class NewModelCreate(NewModelBase):
    """创建新模型"""
    pass

class NewModelUpdate(NewModelBase):
    """更新新模型"""
    name: Optional[str] = None

class NewModel(NewModelBase):
    """新模型响应模型"""
    id: int
    is_active: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

### 添加新前端组件

#### 1. 创建新的Svelte组件

在`frontend/src/lib/components/`目录下创建新的组件：

```svelte
<!-- src/lib/components/NewFeatureComponent.svelte -->
<script>
    import { onMount } from 'svelte';
    import { klineStore } from '$lib/stores.js';
    import { getNewFeatureData } from '$lib/api.js';
    
    // 响应式变量
    let isLoading = false;
    let error = null;
    let data = [];
    let selectedCategory = 'all';
    
    // 生命周期钩子
    onMount(async () => {
        await loadData();
    });
    
    // 加载数据
    async function loadData() {
        isLoading = true;
        error = null;
        try {
            const response = await getNewFeatureData(selectedCategory);
            data = response.data;
        } catch (err) {
            error = err.message;
        } finally {
            isLoading = false;
        }
    }
    
    // 处理类别变化
    function handleCategoryChange(category) {
        selectedCategory = category;
        loadData();
    }
</script>

<div class="p-4">
    <!-- 加载状态 -->
    {#if isLoading}
        <div class="flex items-center justify-center py-8">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-chan-600"></div>
        </div>
    {:else if error}
        <!-- 错误状态 -->
        <div class="bg-red-50 border border-red-200 rounded-lg p-4">
            <p class="text-red-700">加载失败: {error}</p>
            <button 
                on:click={loadData}
                class="mt-2 text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
            >
                重试
            </button>
        </div>
    {:else}
        <!-- 数据展示 -->
        <div class="space-y-4">
            <!-- 控制面板 -->
            <div class="flex space-x-2">
                {#each ['all', 'category1', 'category2'] as category}
                    <button 
                        class="px-3 py-1 rounded text-sm transition-colors {
                            selectedCategory === category 
                                ? 'bg-chan-600 text-white' 
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                        }"
                        on:click={() => handleCategoryChange(category)}
                    >
                        {category}
                    </button>
                {/each}
            </div>
            
            <!-- 数据列表 -->
            <div class="grid gap-4">
                {#each data as item}
                    <div class="border border-gray-200 rounded-lg p-4">
                        <h3 class="font-medium text-gray-900">{item.name}</h3>
                        <p class="text-sm text-gray-600 mt-1">{item.description}</p>
                        <div class="flex justify-between items-center mt-2">
                            <span class="text-sm text-gray-500">状态: {item.status}</span>
                            <span class="text-sm text-gray-500">创建时间: {item.created_at}</span>
                        </div>
                    </div>
                {/each}
            </div>
        </div>
    {/if}
</div>

<style>
    .new-feature-component {
        @apply bg-white rounded-lg shadow-sm;
    }
</style>
```

#### 2. 创建API接口

在`frontend/src/lib/api.js`中添加新的API接口：

```javascript
// 新功能相关API
export async function getNewFeatureData(category = 'all') {
    return await get('/new-feature', {
        category
    });
}

export async function createNewFeature(data) {
    return await post('/new-feature', data);
}

export async function updateNewFeature(id, data) {
    return await put(`/new-feature/${id}`, data);
}

export async function deleteNewFeature(id) {
    return await del(`/new-feature/${id}`);
}
```

#### 3. 创建状态管理

在`frontend/src/lib/stores.js`中创建状态管理：

```javascript
import { writable } from 'svelte/store';

// 新功能数据存储
export const newFeatureStore = writable([]);

// 新功能加载状态
export const newFeatureLoading = writable(false);

// 新功能错误信息
export const newFeatureError = writable(null);

// 新功能筛选条件
export const newFeatureFilters = writable({
    category: 'all',
    status: 'active',
    page: 1,
    pageSize: 10
});
```

#### 4. 在页面中使用组件

在相应的页面中导入和使用新组件：

```svelte
<!-- src/routes/new-feature/+page.svelte -->
<script>
    import NewFeatureComponent from '$components/NewFeatureComponent.svelte';
</script>

<div class="container mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-6">新功能管理</h1>
    <NewFeatureComponent />
</div>
```

**Section sources**
- [README.md](file://README.md#L1168-L1317)
- [app/api/v1/endpoints/kline.py](file://app/api/v1/endpoints/kline.py#L1-L195)
- [app/models/kline.py](file://app/models/kline.py#L1-L37)
- [app/schemas/kline.py](file://app/schemas/kline.py#L1-L30)
- [app/crud/kline.py](file://app/crud/kline.py#L1-L355)
- [app/services/kline_aggregator.py](file://app/services/kline_aggregator.py#L1-L251)
- [frontend/src/lib/api.js](file://frontend/src/lib/api.js#L1-L554)
- [frontend/src/lib/components/KLineChart.svelte](file://frontend/src/lib/components/KLineChart.svelte#L1-L626)

## 测试指南

### 单元测试

系统使用Python的unittest框架进行单元测试。所有单元测试文件应以`test_`开头，并放置在相应的模块目录中。

#### 1. 创建单元测试

在相应模块目录下创建测试文件：

```python
# app/crud/test_kline.py
import unittest
from unittest.mock import Mock, patch
from sqlalchemy.orm import Session
from app.crud.kline import kline
from app.models.kline import BtcUsdtKline
from app.schemas.kline import BtcUsdtKlineCreate

class TestKlineCRUD(unittest.TestCase):
    """K线CRUD操作测试"""
    
    def setUp(self):
        """测试前准备"""
        self.db = Mock(spec=Session)
        self.kline_data = BtcUsdtKlineCreate(
            timestamp=1640995200000,
            open_time="2022-01-01T00:00:00",
            close_time="2022-01-01T00:01:00",
            open_price="50000.0",
            high_price="51000.0",
            low_price="49000.0",
            close_price="50500.0",
            volume="100.0",
            quote_volume="5000000.0",
            trades_count=100,
            taker_buy_volume="60.0",
            taker_buy_quote_volume="3000000.0"
        )
    
    @patch('app.crud.kline.BtcUsdtKline')
    def test_create_kline(self, mock_model):
        """测试创建K线数据"""
        # 准备测试数据
        mock_db_obj = Mock()
        self.db.add.return_value = None
        self.db.commit.return_value = None
        self.db.refresh.return_value = None
        
        # 执行测试
        result = kline.create(db=self.db, obj_in=self.kline_data)
        
        # 验证结果
        self.db.add.assert_called_once()
        self.db.commit.assert_called_once()
        self.db.refresh.assert_called_once()
        self.assertIsNotNone(result)
    
    def test_get_kline_by_id(self):
        """测试根据ID获取K线数据"""
        # 准备测试数据
        mock_kline = Mock(spec=BtcUsdtKline)
        self.db.query.return_value.filter.return_value.first.return_value = mock_kline
        
        # 执行测试
        result = kline.get(db=self.db, symbol="btc_usdt", id=1)
        
        # 验证结果
        self.db.query.assert_called_once()
        self.assertIsNotNone(result)
    
    def test_get_by_timestamp(self):
        """测试根据时间戳获取K线数据"""
        # 准备测试数据
        mock_kline = Mock(spec=BtcUsdtKline)
        self.db.query.return_value.filter.return_value.first.return_value = mock_kline
        
        # 执行测试
        result = kline.get_by_timestamp(db=self.db, symbol="btc_usdt", timestamp=1640995200000)
        
        # 验证结果
        self.db.query.assert_called_once()
        self.assertIsNotNone(result)

if __name__ == '__main__':
    unittest.main()
```

#### 2. 运行单元测试

运行所有单元测试：

```bash
python -m unittest discover -v
```

运行特定模块的测试：

```bash
python -m unittest app.crud.test_kline -v
```

### 集成测试

系统提供`test_chan_integration.py`作为集成测试脚本，用于验证所有组件是否正确集成和工作。

#### 1. 集成测试内容

集成测试包含以下测试项：

- Chan模块导入测试
- 数据库连接测试
- Chan适配器测试
- K线聚合器测试
- 缠论分析功能测试
- 数据获取器测试
- API端点测试

#### 2. 运行集成测试

```bash
python test_chan_integration.py
```

#### 3. 自定义集成测试

可以创建新的集成测试文件：

```python
# test_new_feature_integration.py
import sys
import os
from pathlib import Path
import requests
import time
from datetime import datetime

project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

def test_new_feature_api():
    """测试新功能API端点"""
    print("🔍 测试新功能API端点...")
    
    try:
        base_url = "http://localhost:8000"
        
        # 测试获取数据
        response = requests.get(f"{base_url}/api/v1/new-feature", timeout=5)
        if response.status_code == 200:
            print("✅ 新功能API端点正常")
            return True, "新功能API工作正常"
        else:
            print(f"❌ 新功能API返回状态码: {response.status_code}")
            return False, f"新功能API异常 ({response.status_code})"
            
    except Exception as e:
        print(f"❌ 新功能API测试失败: {e}")
        return False, f"新功能API测试失败"

def run_integration_test():
    """运行完整的集成测试"""
    print("🐢 缠论分析系统 - 新功能集成测试")
    print("=" * 50)
    
    tests = [
        ("新功能API端点", test_new_feature_api),
    ]
    
    results = {}
    
    for test_name, test_func in tests:
        try:
            success, message = test_func()
            results[test_name] = {"success": success, "message": message}
        except Exception as e:
            print(f"❌ {test_name}测试异常: {e}")
            results[test_name] = {"success": False, "message": f"测试异常: {str(e)}"}
    
    # 总结报告
    print("\n" + "=" * 50)
    print("📋 集成测试报告:")
    
    passed = 0
    total = len(tests)
    
    for test_name, result in results.items():
        status = "✅ 通过" if result["success"] else "❌ 失败"
        print(f"   {test_name:15} : {status}")
        print(f"   {' ' * 15}   {result['message']}")
        
        if result["success"]:
            passed += 1
    
    print(f"\n📊 测试结果: {passed}/{total} 通过")
    
    return passed == total, results

if __name__ == "__main__":
    success, results = run_integration_test()
    sys.exit(0 if success else 1)
```

### 前端测试

前端使用Svelte Testing Library进行组件测试。

#### 1. 创建组件测试

```javascript
// frontend/src/lib/components/__tests__/NewFeatureComponent.test.js
import { render, screen, fireEvent } from '@testing-library/svelte';
import NewFeatureComponent from '../NewFeatureComponent.svelte';
import { klineStore } from '$lib/stores.js';
import { getNewFeatureData } from '$lib/api.js';

// 模拟API调用
jest.mock('$lib/api.js', () => ({
    getNewFeatureData: jest.fn()
}));

describe('NewFeatureComponent', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    
    test('显示加载状态', async () => {
        getNewFeatureData.mockResolvedValue({ data: [] });
        
        render(NewFeatureComponent);
        
        expect(screen.getByText('加载图表中...')).toBeInTheDocument();
    });
    
    test('显示数据列表', async () => {
        const mockData = [
            { id: 1, name: 'Feature 1', description: 'Description 1' },
            { id: 2, name: 'Feature 2', description: 'Description 2' }
        ];
        
        getNewFeatureData.mockResolvedValue({ data: mockData });
        
        render(NewFeatureComponent);
        
        // 等待数据加载
        await screen.findByText('Feature 1');
        
        expect(screen.getByText('Feature 1')).toBeInTheDocument();
        expect(screen.getByText('Feature 2')).toBeInTheDocument();
    });
    
    test('处理类别切换', async () => {
        const mockData = [{ id: 1, name: 'Feature 1' }];
        
        getNewFeatureData.mockResolvedValue({ data: mockData });
        
        render(NewFeatureComponent);
        
        // 等待数据加载
        await screen.findByText('Feature 1');
        
        // 点击类别按钮
        const categoryButton = screen.getByText('category1');
        fireEvent.click(categoryButton);
        
        expect(getNewFeatureData).toHaveBeenCalledWith('category1');
    });
});
```

#### 2. 运行前端测试

```bash
cd frontend
npm run test
```

### 测试覆盖率

使用coverage.py工具检查测试覆盖率：

```bash
# 安装coverage
pip install coverage

# 运行测试并生成覆盖率报告
coverage run -m unittest discover
coverage report
coverage html
```

**Section sources**
- [test_chan_integration.py](file://test_chan_integration.py#L1-L401)

## 工具链与自动化

### 项目依赖管理

#### 1. Python依赖

项目使用`requirements.txt`管理Python依赖：

```txt
fastapi>=0.68.0
uvicorn>=0.15.0
sqlalchemy>=1.4.23
pydantic>=2.0.0
pydantic-settings>=2.0.0
python-dotenv>=0.19.0
psycopg2-binary>=2.9.1
alembic>=1.7.1
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
websockets>=10.0
python-multipart>=0.0.5
aiohttp>=3.8.1
typer>=0.9.0
ccxt>=4.0.0
pandas>=2.0.0
certifi>=2024.2.0
```

#### 2. 前端依赖

项目使用`package.json`管理前端依赖：

```json
{
  "name": "chan-analysis-frontend",
  "version": "1.0.0",
  "description": "缠论分析系统前端 - Svelte + KLineCharts专业界面",
  "type": "module",
  "scripts": {
    "dev": "vite dev --port 3000",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
    "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
    "lint": "prettier --plugin-search-dir . --check . && eslint .",
    "format": "prettier --plugin-search-dir . --write ."
  },
  "devDependencies": {
    "@sveltejs/adapter-auto": "^2.1.1",
    "@sveltejs/adapter-static": "^2.0.3",
    "@sveltejs/kit": "^1.27.4",
    "svelte": "^4.2.7",
    "svelte-check": "^3.6.0",
    "typescript": "^5.0.0",
    "vite": "^4.4.2",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.0",
    "@tailwindcss/forms": "^0.5.6",
    "@tailwindcss/typography": "^0.5.10"
  },
  "dependencies": {
    "klinecharts": "^9.8.12",
    "lucide-svelte": "^0.294.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
```

### 代码格式化与检查

#### 1. Svelte配置

`frontend/svelte.config.js`配置了项目的基本设置：

```javascript
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/kit/vite';

const config = {
  preprocess: vitePreprocess(),
  kit: {
    adapter: adapter(),
    alias: {
      '$components': 'src/lib/components',
      '$stores': 'src/lib/stores.js',
      '$utils': 'src/lib/utils.js',
      '$api': 'src/lib/api.js'
    },
    prerender: {
      handleHttpError: 'warn'
    },
    csp: {
      mode: 'auto',
      directives: {
        'script-src': ['self', 'unsafe-inline']
      }
    }
  }
};

export default config;
```

#### 2. 代码格式化

使用Prettier进行代码格式化：

```bash
# 格式化所有文件
npm run format

# 检查格式
npm run lint
```

#### 3. 类型检查

使用Svelte Check进行类型检查：

```bash
npm run check
```

### 构建与部署

#### 1. 前端构建

```bash
# 开发模式
npm run dev

# 构建生产版本
npm run build

# 预览生产版本
npm run preview
```

#### 2. 后端部署

使用Uvicorn部署后端服务：

```bash
# 开发模式
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# 生产模式
uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4
```

#### 3. Docker部署

可以创建Dockerfile进行容器化部署：

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Section sources**
- [requirements.txt](file://requirements.txt#L1-L18)
- [frontend/package.json](file://frontend/package.json#L1-L53)
- [frontend/svelte.config.js](file://frontend/svelte.config.js#L1-L39)

## Pull Request审查流程

### Pull Request标准

所有Pull Request必须满足以下标准：

1. **代码质量**：
   - 代码遵循项目代码规范
   - 有适当的注释和文档
   - 无明显的性能问题
   - 无安全漏洞

2. **测试覆盖率**：
   - 包含相应的单元测试
   - 测试覆盖主要功能路径
   - 通过所有测试

3. **文档完整性**：
   - 更新相关文档
   - 添加必要的API文档
   - 更新README（如需要）

4. **功能正确性**：
   - 实现预期功能
   - 无明显Bug
   - 用户体验良好

### Pull Request审查流程

#### 1. 创建Pull Request

```bash
# 1. Fork并克隆项目
git clone https://github.com/your-username/turtle.git
cd turtle

# 2. 创建功能分支
git checkout -b feature/new-feature

# 3. 开发和测试
# 进行开发...
python test_chan_integration.py

# 4. 提交更改
git add .
git commit -m "feat: 添加新功能"
git push origin feature/new-feature

# 5. 创建Pull Request
# 在GitHub上创建PR
```

#### 2. 审查检查清单

审查者将根据以下清单进行审查：

- [ ] 代码是否遵循PEP 8和Svelte风格规范
- [ ] 是否有适当的类型提示和文档字符串
- [ ] 是否包含相应的测试用例
- [ ] 测试是否通过
- [ ] 是否更新了相关文档
- [ ] 代码是否有重复或可以重构的部分
- [ ] 是否有潜在的性能问题
- [ ] 是否有安全漏洞
- [ ] 功能是否按预期工作
- [ ] 用户体验是否良好

#### 3. 审查反馈

审查者将提供具体的反馈，包括：

- 代码改进建议
- 测试补充建议
- 文档更新建议
- 潜在问题提醒

#### 4. 修订与合并

贡献者根据反馈进行修订：

```bash
# 1. 修改代码
# 进行修改...

# 2. 添加测试
# 添加测试...

# 3. 提交修订
git add .
git commit -m "fix: 修复审查反馈的问题"
git push origin feature/new-feature
```

当所有审查意见都得到妥善处理后，Pull Request将被合并。

### 贡献流程总结

1. **报告问题**：在GitHub Issues中提交bug报告或功能建议
2. **代码贡献**：Fork项目，创建功能分支，提交Pull Request
3. **文档改进**：改进文档、添加示例、翻译内容
4. **测试反馈**：测试新功能，提供使用反馈

我们鼓励高质量的代码贡献，确保项目的长期健康发展。

**Section sources**
- [README.md](file://README.md#L1318-L1467)

## 附录

### 项目结构说明

```
turtle/
├── 🐍 后端 (Python/FastAPI)
│   ├── app/
│   │   ├── api/v1/          # API路由和端点
│   │   ├── core/            # 核心配置和异常处理
│   │   ├── crud/            # 数据库操作
│   │   ├── db/              # 数据库连接和会话
│   │   ├── models/          # SQLAlchemy模型
│   │   ├── schemas/         # Pydantic模式
│   │   ├── scripts/         # 数据获取脚本
│   │   └── services/        # 业务逻辑服务
│   ├── chan.py/             # Chan模块子模块
│   ├── logs/                # 日志文件
│   └── static/              # 静态文件目录
│
├── 🌐 前端 (Svelte)
│   ├── src/
│   │   ├── lib/
│   │   │   ├── components/  # Svelte组件
│   │   │   ├── stores.js    # 状态管理
│   │   │   ├── api.js       # API接口
│   │   │   └── utils.js     # 工具函数
│   │   └── routes/          # 路由页面
│   ├── static/              # 静态资源
│   └── dist/                # 构建输出
│
└── 📋 配置文件
    ├── requirements.txt     # Python依赖
    ├── .env.example        # 环境变量示例
    ├── create_tables.py    # 数据库初始化
    ├── quick_start.py      # 快速启动脚本
    └── test_chan_integration.py  # 集成测试
```

### 常见问题解决

#### 1. 数据库连接失败
```bash
# 检查PostgreSQL服务
sudo systemctl status postgresql  # Linux
brew services list | grep postgresql  # macOS

# 检查连接配置
psql -h localhost -U postgres -d turtle
```

#### 2. Chan模块不可用
```bash
# 重新初始化子模块
git submodule update --init --recursive

# 检查模块状态
python -c "from app.services.chan_adapter import chan_adapter; print(chan_adapter.get_chan_info())"
```

#### 3. API连接超时
```bash
# 检查网络连接
curl -I https://api.binance.com/api/v3/ping

# 调整超时配置（.env文件）
API_TIMEOUT=60
```

#### 4. 前端构建失败
```bash
cd frontend

# 清理依赖
rm -rf node_modules package-lock.json
npm install

# 检查Node.js版本
node --version  # 需要16.0+
```

### 日志调试

系统日志存储在 `logs/app.log`，可以通过以下方式查看：

```bash
# 查看实时日志
tail -f logs/app.log

# 搜索错误信息
grep -i error logs/app.log

# 查看最近100行
tail -n 100 logs/app.log
```

**Section sources**
- [README.md](file://README.md#L1468-L1617)