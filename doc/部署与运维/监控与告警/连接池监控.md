# 连接池监控

<cite>
**本文档引用的文件**
- [performance_recommendations.md](file://performance_recommendations.md)
- [app/db/session.py](file://app/db/session.py)
- [app/core/config.py](file://app/core/config.py)
- [app/core/logger.py](file://app/core/logger.py)
- [app/api/v1/endpoints/kline_simple.py](file://app/api/v1/endpoints/kline_simple.py)
</cite>

## 目录
1. [引言](#引言)
2. [连接池配置分析](#连接池配置分析)
3. [监控关键指标](#监控关键指标)
4. [连接泄漏检测机制](#连接泄漏检测机制)
5. [健康检查实现](#健康检查实现)
6. [告警策略与阈值设定](#告警策略与阈值设定)
7. [总结](#总结)

## 引言
数据库连接池是系统性能和稳定性的关键组件。在高并发交易系统中，合理监控连接池状态对于预防资源耗尽、识别连接泄漏和保障服务可用性至关重要。本文档基于 `performance_recommendations.md` 中的优化建议，结合 `app/db/session.py` 的实际配置，详细说明如何实施连接池监控，包括关键指标采集、泄漏检测、健康检查实现及告警策略。

## 连接池配置分析
根据 `app/db/session.py` 文件中的配置，当前系统使用 SQLAlchemy 的连接池，其核心参数如下：

```python
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=10,        # 基础连接池大小
    max_overflow=20,     # 最大溢出连接数
    pool_timeout=30,     # 获取连接的超时时间（秒）
    pool_recycle=3600,   # 连接回收周期（秒，即1小时）
    pool_pre_ping=True,  # 每次使用前进行连接有效性检查
    ...
)
```

**配置解读**：
- **基础连接池大小 (pool_size)**：10。这意味着连接池会始终保持10个活跃连接，以应对常规负载。
- **最大溢出连接数 (max_overflow)**：20。当并发请求超过基础池大小时，连接池最多可额外创建20个连接，因此系统最多可同时处理30个数据库连接。
- **连接回收 (pool_recycle)**：3600秒（1小时）。此设置可防止数据库因长时间空闲连接而将其关闭，避免 `MySQL server has gone away` 类似错误。
- **预检查 (pool_pre_ping)**：启用。在每次从池中获取连接前，会先执行一个轻量级的 `SELECT 1` 检查，确保连接有效，从而提高连接的可靠性。

**Section sources**
- [app/db/session.py](file://app/db/session.py#L10-L25)

## 监控关键指标
要有效监控连接池，必须实时采集以下关键指标：

1.  **当前活跃连接数 (In-use Connections)**：当前正在被应用程序使用的连接数量。这是衡量系统负载最直接的指标。
2.  **空闲连接数 (Idle Connections)**：当前在连接池中但未被使用的连接数量。它等于 `pool_size` 减去活跃连接数（在未溢出时）。
3.  **等待连接的线程数 (Waiting Threads)**：当所有连接（包括溢出连接）都被占用时，新的请求线程将进入等待状态。此指标为0表示连接充足，大于0则表示连接池已饱和，系统性能将严重下降。
4.  **总连接数 (Total Connections)**：当前数据库后端的总连接数，等于活跃连接数加上空闲连接数。

这些指标可以通过 SQLAlchemy 的引擎状态接口获取。例如，通过 `engine.pool.status()` 可以返回一个包含上述信息的元组。

## 连接泄漏检测机制
连接泄漏是导致连接池耗尽的主要原因之一，通常由代码中未正确关闭数据库会话（session）引起。

**检测机制**：
1.  **定期检查长时间未释放的连接**：可以结合数据库的系统视图（如 PostgreSQL 的 `pg_stat_activity`）来监控。通过查询长时间处于 `idle in transaction` 或 `active` 状态的连接，可以识别潜在的泄漏。
2.  **应用层日志追踪**：在 `app/db/session.py` 中，`get_db()` 函数使用了 `yield` 和 `finally` 语句块，确保 `db.close()` 总是被调用。同时，它通过 `db_logger.debug` 记录了会话的创建和关闭。通过分析日志中 `Creating new database session` 和 `Closing database session` 的匹配情况，可以发现未被正确关闭的会话。

**实现建议**：
- 在健康检查端点中，除了检查数据库连通性，还应查询并返回当前数据库的总连接数和长时连接数。
- 设置一个后台任务，定期扫描日志，统计在一定时间窗口内（如5分钟）有创建日志但无关闭日志的会话，作为泄漏的预警信号。

**Section sources**
- [app/db/session.py](file://app/db/session.py#L38-L43)
- [app/core/logger.py](file://app/core/logger.py#L40-L44)

## 健康检查实现
系统已实现一个 `/health` 健康检查端点（位于 `app/api/v1/endpoints/kline_simple.py`），该端点可以作为监控的基础。

```python
@router.get("/health")
def health_check(db: Session = Depends(get_db)):
    """健康检查 - 检查K线API和数据库状态"""
    try:
        # 检查数据库连接
        stats = kline_aggregator.get_data_statistics(db)
        data_available = stats.get("total_klines", 0) > 0
        ...
        return create_success_response(data={
            "status": "healthy",
            "components": {
                "database": "connected",
                "kline_aggregator": "ready",
                "data_available": data_available,
                "data_freshness": data_freshness
            },
            "statistics": stats,
            ...
        })
    except Exception as e:
        app_logger.error(f"❌ 健康检查失败: {str(e)}")
        raise HTTPException(status_code=500, detail="健康检查失败")
```

**增强健康检查以包含连接池状态**：
可以扩展此端点，通过 SQLAlchemy 引擎直接获取连接池状态，并将其纳入返回结果。

```python
from app.db.session import engine

@router.get("/detailed-health")
def detailed_health_check():
    """详细的健康检查，包含连接池状态"""
    try:
        # 获取连接池状态
        pool_status = engine.pool.status()
        # pool_status 返回 (in_use, overflow, pool_size)
        in_use, overflow, total_size = pool_status
        
        # 计算空闲连接
        idle = total_size - in_use if in_use <= total_size else 0
        
        return create_success_response(data={
            "status": "healthy",
            "components": {
                "database": "connected",
                "connection_pool": {
                    "in_use": in_use,
                    "idle": idle,
                    "overflow": overflow,
                    "total_size": total_size,
                    "max_overflow": 20
                }
            },
            "recommendations": {
                "high_usage": "连接池使用率过高，请关注"
            } if in_use > 8 else {}
        })
    except Exception as e:
        app_logger.error(f"详细健康检查失败: {str(e)}")
        raise HTTPException(status_code=500, detail="详细健康检查失败")
```

**Section sources**
- [app/api/v1/endpoints/kline_simple.py](file://app/api/v1/endpoints/kline_simple.py#L237-L259)
- [app/db/session.py](file://app/db/session.py#L1-L10)

## 告警策略与阈值设定
基于连接池的配置（`pool_size=10`, `max_overflow=20`），可以设定以下监控阈值和告警策略：

| 指标 | 告警级别 | 阈值 | 告警策略 |
| :--- | :--- | :--- | :--- |
| **活跃连接数** | 警告 (Warning) | > 8 | 当活跃连接数持续超过8时，发出警告，提示系统负载较高，接近基础池上限。 |
| **活跃连接数** | 严重 (Critical) | > 25 | 当活跃连接数超过25时，发出严重告警，表明连接池已严重饱和，有耗尽风险。 |
| **溢出连接数** | 警告 (Warning) | > 0 | 一旦出现溢出连接，即发出警告，说明基础池已不足以应对当前负载。 |
| **等待线程数** | 严重 (Critical) | > 0 | 任何等待线程都应触发严重告警，因为这直接导致请求延迟和超时。 |
| **长时连接数** | 警告 (Warning) | > 0 | 发现任何超过30分钟的空闲事务连接，应发出警告，怀疑存在连接泄漏。 |

**告警实现**：
- 将上述 `detailed_health_check` 端点的输出接入 Prometheus 等监控系统。
- 在监控系统中配置告警规则（Alerting Rules），当指标超过阈值时，通过邮件、短信或企业微信等方式通知运维人员。

## 总结
有效的连接池监控是保障交易系统稳定运行的基石。通过监控活跃、空闲和溢出连接数，可以实时掌握系统负载。通过分析应用日志和数据库会话，可以有效检测连接泄漏。结合系统现有的健康检查机制，扩展其实现以包含详细的连接池状态，并设定合理的告警阈值，能够帮助团队在问题发生前及时发现并处理，从而提升系统的整体健壮性和可观测性。