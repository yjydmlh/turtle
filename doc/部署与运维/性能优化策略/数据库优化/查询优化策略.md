# 查询优化策略

<cite>
**本文档引用的文件**  
- [kline_aggregator.py](file://app/services/kline_aggregator.py)
- [database_optimization.sql](file://database_optimization.sql)
- [kline.py](file://app/crud/kline.py)
- [models/kline.py](file://app/models/kline.py)
</cite>

## 目录
1. [引言](#引言)
2. [Kline模型结构与索引设计](#kline模型结构与索引设计)
3. [常见查询场景分析](#常见查询场景分析)
4. [ORM查询优化实践](#orm查询优化实践)
5. [批量数据读取性能优化](#批量数据读取性能优化)
6. [总结](#总结)

## 引言
本文档旨在为交易系统中的K线数据查询提供全面的优化策略。通过分析`kline_aggregator.py`中的数据访问模式和`Kline`模型结构，提出一系列查询优化建议，以提升系统性能和响应速度。

## Kline模型结构与索引设计

### 模型结构
`Kline`模型定义了K线数据的基本结构，包括开盘时间、收盘时间、价格、成交量等字段。该模型通过SQLAlchemy ORM映射到数据库表，支持多种时间周期的K线数据存储。

### 索引设计
根据`database_optimization.sql`文件中的定义，为K线数据表添加了必要的索引以提升查询性能：

```sql
-- BTC/USDT表索引优化
CREATE INDEX IF NOT EXISTS idx_btc_usdt_open_time ON btc_usdt(open_time DESC);
CREATE INDEX IF NOT EXISTS idx_btc_usdt_timestamp ON btc_usdt(timestamp);
CREATE INDEX IF NOT EXISTS idx_btc_usdt_time_range ON btc_usdt(open_time, close_time);
```

这些索引的设计考虑了常见的查询场景，如按时间范围查询K线数据，确保查询能够高效利用索引避免全表扫描。

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L5-L10)

## 常见查询场景分析

### 按时间范围获取K线数据
在实际应用中，按时间范围获取K线数据是最常见的查询场景之一。例如，用户可能需要获取过去24小时内的1小时K线数据。为了优化此类查询，应优先使用`open_time`字段进行过滤，并利用已创建的索引。

```python
query = db.query(BtcUsdtKline)
if start_time:
    query = query.filter(BtcUsdtKline.open_time >= start_time)
if end_time:
    query = query.filter(BtcUsdtKline.open_time < end_time)
```

### 获取最新K线数据
获取最新的K线数据是另一个常见场景。在这种情况下，可以通过`ORDER BY open_time DESC`并结合`LIMIT`子句来实现高效查询。

```python
klines = query.order_by(BtcUsdtKline.open_time.desc()).limit(limit).all()
```

**Section sources**
- [kline_aggregator.py](file://app/services/kline_aggregator.py#L77-L116)

## ORM查询优化实践

### 避免SELECT *
在编写ORM查询时，应避免使用`SELECT *`，而是只选择必要的字段以减少I/O开销。例如，在只需要开盘价和收盘价的情况下，可以明确指定所需字段：

```python
result = db.query(BtcUsdtKline.open_price, BtcUsdtKline.close_price).filter(
    BtcUsdtKline.open_time >= start_time,
    BtcUsdtKline.open_time < end_time
).all()
```

### 利用索引字段
在`WHERE`条件中优先使用索引字段，如`open_time`和`timestamp`，以确保查询能够利用索引加速。此外，在`ORDER BY`子句中利用索引顺序可以减少排序成本。

```python
query = db.query(BtcUsdtKline).filter(
    BtcUsdtKline.open_time >= start_time,
    BtcUsdtKline.open_time < end_time
).order_by(BtcUsdtKline.open_time)
```

**Section sources**
- [kline.py](file://app/crud/kline.py#L60-L89)

## 批量数据读取性能优化

### 使用execution_options预加载
在进行批量数据读取时，可以通过`execution_options`预加载策略优化性能。例如，在获取大量K线数据时，可以使用`yield_per`选项分批加载数据，避免内存溢出。

```python
query = db.query(BtcUsdtKline).filter(
    BtcUsdtKline.open_time >= start_time,
    BtcUsdtKline.open_time < end_time
).execution_options(yield_per=1000)
```

### 原生SQL查询
对于复杂的聚合查询，可以使用原生SQL查询以获得更好的性能。例如，在`CRUDKline`类中定义的`get_aggregated_klines`方法使用了原生SQL进行时间桶聚合。

```python
sql = text("""
    SELECT 
        EXTRACT(EPOCH FROM time_bucket(:interval_minutes * '1 minute', k.open_time))::BIGINT * 1000 as timestamp,
        time_bucket(:interval_minutes * '1 minute', k.open_time) as open_time,
        ...
    FROM btc_usdt k
""")
```

**Section sources**
- [kline.py](file://app/crud/kline.py#L177-L203)

## 总结
通过合理设计索引、优化ORM查询和利用预加载策略，可以显著提升K线数据查询的性能。在实际应用中，应根据具体需求选择合适的优化策略，确保系统高效稳定运行。