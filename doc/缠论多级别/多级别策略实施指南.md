# 多级别联立自动化交易策略 - 实施指南

> **前提条件**：已有完整的chan.py缠论分析模块

## 🎯 策略核心（三句话说清楚）

1. **4小时看方向**：最近的买卖点决定做多还是做空
2. **1小时找时机**：在允许的方向上，等待回调或突破机会  
3. **30分钟抓入场**：用买卖点或分型确认精确入场和止损

---

## 📊 决策流程图

```
┌──────────────────────────────────────────┐
│  步骤1：获取各级别chan分析结果            │
│  - 4H: 买卖点、中枢                      │
│  - 1H: 买卖点、中枢                      │
│  - 30M: 买卖点、分型                     │
└──────────────┬───────────────────────────┘
               ↓
┌──────────────────────────────────────────┐
│  步骤2：4H趋势判断                        │
│                                          │
│  IF 最近是买点(1buy/2buy/3buy):          │
│    → 允许做多，禁止做空                  │
│  ELIF 最近是卖点(1sell/2sell/3sell):     │
│    → 允许做空，禁止做多                  │
│  ELSE:                                   │
│    → 观望                                │
└──────────────┬───────────────────────────┘
               ↓
┌──────────────────────────────────────────┐
│  步骤3：1H机会识别                        │
│                                          │
│  IF 允许做多 AND 1H出现买点:              │
│    → 准备做多                            │
│  ELIF 允许做空 AND 1H出现卖点:            │
│    → 准备做空                            │
│  ELSE:                                   │
│    → 继续等待                            │
└──────────────┬───────────────────────────┘
               ↓
┌──────────────────────────────────────────┐
│  步骤4：30M入场确认                       │
│                                          │
│  IF 准备做多 AND (30M买点 OR 底分型):     │
│    → 开多单                              │
│    → 止损 = 30M低点 × 0.98               │
│  ELIF 准备做空 AND (30M卖点 OR 顶分型):   │
│    → 开空单                              │
│    → 止损 = 30M高点 × 1.02               │
└──────────────┬───────────────────────────┘
               ↓
┌──────────────────────────────────────────┐
│  步骤5：仓位计算                          │
│                                          │
│  仓位 = (净值 × 2% × 信号系数) / 止损距离 │
│                                          │
│  信号系数:                               │
│  - 高置信度(>0.8): 1.5倍                 │
│  - 中置信度(0.6-0.8): 1.0倍              │
│  - 低置信度(<0.6): 0.5倍                 │
└──────────────┬───────────────────────────┘
               ↓
┌──────────────────────────────────────────┐
│  步骤6：持仓管理                          │
│                                          │
│  每次30M更新检查:                         │
│  - 30M笔破坏 → 减仓50% + 保本止损         │
│  - 1H笔破坏 → 全部平仓                   │
│  - 4H趋势反转 → 立即平仓                 │
└──────────────────────────────────────────┘
```

---

## 💻 核心代码（已实现）

### 1. 简化版策略类

**文件**：`app/services/multi_level_strategy_simple.py`

**核心方法**：

```python
class MultiLevelStrategy:
    
    def analyze(self, chan_data):
        """
        执行多级别分析
        
        输入：
        chan_data = {
            '30m': {'fenxings': [], 'bis': [], 'bsps': [], ...},
            '1h': {'fenxings': [], 'bis': [], 'bsps': [], ...},
            '4h': {'fenxings': [], 'bis': [], 'bsps': [], ...}
        }
        
        输出：
        {
            'action': 'open_long' / 'open_short' / 'wait',
            'signal': EntrySignal对象或None,
            'position_size': 仓位信息或None,
            'reason': 决策理由
        }
        """
        
        # 1. 大级别趋势判断
        trend = self._analyze_major_trend(chan_data['4h'])
        
        # 2. 中级别机会识别  
        opportunity = self._identify_opportunity(chan_data['1h'], trend)
        
        # 3. 小级别入场确认
        signal = self._determine_entry(chan_data['30m'], opportunity)
        
        # 4. 计算仓位
        position_size = self._calculate_position(signal)
        
        return {结果}
```

### 2. 与chan.py的集成

```python
# 从chan.py获取数据
from Chan import CChan
from ChanConfig import CChanConfig

# 创建多个级别的Chan实例
chan_30m = CChan(code="BTC/USDT", lv_list=[KL_TYPE.K_30M], ...)
chan_1h = CChan(code="BTC/USDT", lv_list=[KL_TYPE.K_60M], ...)
chan_4h = CChan(code="BTC/USDT", lv_list=[KL_TYPE.K_4H], ...)

# 提取所需数据
chan_data = {
    '30m': {
        'fenxings': chan_30m[-1].fx_list,
        'bis': chan_30m[-1].bi_list,
        'bsps': chan_30m[-1].bs_point_lst,
        'last_price': chan_30m[-1][-1].close
    },
    '1h': {...},
    '4h': {...}
}

# 运行策略
strategy = MultiLevelStrategy()
result = strategy.analyze(chan_data)

# 根据结果执行交易
if result['action'] in ['open_long', 'open_short']:
    # 开仓
    execute_trade(result)
```

---

## 📝 详细实施步骤

### 阶段一：准备工作（1天）

#### 1.1 确认chan.py可用

```python
# 测试chan.py是否正常工作
from Chan import CChan

chan = CChan(code="BTC/USDT", ...)
print(f"分型数量: {len(chan[-1].fx_list)}")
print(f"笔数量: {len(chan[-1].bi_list)}")
print(f"买卖点: {len(chan[-1].bs_point_lst)}")

# ✓ 如果能正常输出，说明chan.py工作正常
```

#### 1.2 理解chan.py的数据结构

```python
# 分型 (fenxing)
fx = chan[-1].fx_list[-1]
print(fx.type)   # 'top' or 'bottom'
print(fx.price)  # 分型价格

# 笔 (bi)
bi = chan[-1].bi_list[-1]
print(bi.direction)  # 'up' or 'down'
print(bi.start.price, bi.end.price)

# 买卖点 (bsp)
bsp = chan[-1].bs_point_lst[-1]
print(bsp.is_buy)  # True/False
print(bsp.type)    # '1buy', '2buy', '3buy'等
print(bsp.klu.close)  # K线收盘价
```

### 阶段二：核心逻辑实现（2-3天）

#### 2.1 实现趋势判断

```python
def analyze_major_trend(bsps_4h):
    """
    最简单的实现：基于最近买卖点判断
    """
    if not bsps_4h:
        return {'can_long': False, 'can_short': False}
    
    latest = bsps_4h[-1]
    
    if latest.is_buy:
        return {
            'direction': 'up',
            'can_long': True,
            'can_short': False,
            'reason': f'4H{latest.type}'
        }
    else:
        return {
            'direction': 'down',
            'can_long': False,
            'can_short': True,
            'reason': f'4H{latest.type}'
        }
```

**测试**：
- ✓ 4H出现1buy → 应返回can_long=True
- ✓ 4H出现1sell → 应返回can_short=True

#### 2.2 实现机会识别

```python
def identify_opportunity(bsps_1h, trend):
    """
    在允许的方向上寻找1H机会
    """
    if not bsps_1h:
        return None
    
    latest = bsps_1h[-1]
    
    # 方向一致才返回机会
    if trend['can_long'] and latest.is_buy:
        return {
            'type': 'long',
            'trigger': f'1H{latest.type}',
            'price': latest.klu.close
        }
    
    if trend['can_short'] and not latest.is_buy:
        return {
            'type': 'short',
            'trigger': f'1H{latest.type}',
            'price': latest.klu.close
        }
    
    return None
```

**测试**：
- ✓ 4H允许做多 + 1H出现买点 → 应返回long机会
- ✓ 4H禁止做多 + 1H出现买点 → 应返回None

#### 2.3 实现入场确认

```python
def determine_entry(data_30m, opportunity):
    """
    用30M买卖点或分型确认入场
    """
    if not opportunity:
        return None
    
    bsps = data_30m.get('bsps', [])
    
    if bsps:
        latest = bsps[-1]
        
        # 做多机会 + 30M买点
        if opportunity['type'] == 'long' and latest.is_buy:
            return {
                'action': 'open_long',
                'entry_price': latest.klu.close,
                'stop_loss': latest.klu.low * 0.98,
                'reason': f"{opportunity['trigger']} + 30M{latest.type}"
            }
    
    return None
```

**测试**：
- ✓ 1H做多机会 + 30M买点 → 应返回开多信号
- ✓ 1H做多机会 + 30M卖点 → 应返回None

### 阶段三：测试验证（3-5天）

#### 3.1 单元测试

```python
# test_multi_level_strategy.py

def test_trend_判断():
    # 测试4H买点 → 允许做多
    bsps = [MockBSP(is_buy=True, type='1buy')]
    trend = analyze_major_trend(bsps)
    assert trend['can_long'] == True
    assert trend['can_short'] == False

def test_机会识别():
    # 测试允许做多 + 1H买点 → 发现机会
    trend = {'can_long': True, 'can_short': False}
    bsps = [MockBSP(is_buy=True)]
    opp = identify_opportunity(bsps, trend)
    assert opp is not None
    assert opp['type'] == 'long'

def test_入场确认():
    # 测试做多机会 + 30M买点 → 确认入场
    opp = {'type': 'long', 'trigger': '1H买点'}
    data = {'bsps': [MockBSP(is_buy=True)]}
    signal = determine_entry(data, opp)
    assert signal is not None
    assert signal['action'] == 'open_long'
```

#### 3.2 历史数据回测

```python
# 选取3-6个月的历史数据
# 逐个时间点推进，记录每次决策

results = []
for timestamp in historical_timestamps:
    # 获取当时的chan数据
    chan_data = get_chan_data_at_time(timestamp)
    
    # 运行策略
    decision = strategy.analyze(chan_data)
    
    # 记录决策
    results.append({
        'time': timestamp,
        'action': decision['action'],
        'reason': decision['reason']
    })

# 统计
total_signals = len([r for r in results if r['action'] != 'wait'])
print(f"总信号数: {total_signals}")
print(f"平均频率: {total_signals / months}次/月")
```

**预期指标**：
- 信号频率：月3-10次
- 做多做空比例：基本平衡（±20%）
- 大级别趋势判断准确性：>70%

### 阶段四：优化调整（持续）

#### 4.1 参数优化

```python
# 可调参数
PARAMS = {
    'stop_loss_ratio': 0.02,    # 止损比例（默认2%）
    'signal_coef_high': 1.5,    # 高置信度系数
    'signal_coef_mid': 1.0,     # 中置信度系数
    'signal_coef_low': 0.5,     # 低置信度系数
    'max_position_pct': 0.30,   # 最大仓位30%
}

# 网格搜索最优参数
for stop_ratio in [0.015, 0.02, 0.025]:
    for high_coef in [1.3, 1.5, 1.7]:
        # 运行回测
        result = backtest(stop_ratio, high_coef)
        # 记录结果
```

#### 4.2 特殊情况处理

```python
# 情况1：连续止损
if consecutive_losses >= 3:
    # 降低风险
    base_risk *= 0.5
    # 提高置信度要求
    min_confidence = 0.7

# 情况2：大级别矛盾
if (trend_4h['direction'] == 'up' and 
    trend_1h['direction'] == 'down'):
    # 观望，等待一致
    return None

# 情况3：止损过大
if stop_distance > entry_price * 0.05:  # 超过5%
    # 放弃交易
    return None
```

---

## 🎯 关键成功因素

### 1. 简化优于复杂

```
❌ 错误：追求完美的信号，考虑所有因素
✓ 正确：抓住核心逻辑，忽略次要因素

核心：大级别方向 + 小级别入场
次要：MACD、成交量、波动率等
```

### 2. 纪律优于技巧

```
策略规则：
1. 大级别禁止的方向，绝不交易
2. 小级别未确认，绝不开仓
3. 止损触发，立即执行
4. 结构破坏，立即出场

情绪陷阱：
× "这次不一样"
× "再等等看"
× "已经亏这么多了"
× "错过可惜"
```

### 3. 验证优于假设

```python
# 不要假设策略有效，要验证

步骤1：历史数据回测（至少3个月）
步骤2：模拟盘运行（至少1个月）
步骤3：小资金实盘（$500-1000）
步骤4：逐步增加资金

只有通过前一步，才能进入下一步
```

---

## 📊 预期效果

基于缠论理论和回测经验：

| 指标 | 保守预期 | 理想目标 |
|-----|---------|---------|
| 月交易频率 | 3-5次 | 8-12次 |
| 胜率 | 55-60% | 65-70% |
| 盈亏比 | 1.5:1 | 2.5:1 |
| 月收益率 | 2-4% | 6-10% |
| 最大回撤 | <15% | <10% |

**关键**：
- 不追求每次都赚
- 追求长期稳定盈利
- 严格控制回撤

---

## ⚠️ 风险提示

### 1. 技术风险

- chan.py可能有bug或误判
- 网络延迟导致数据不同步
- 交易所API可能失败

**应对**：
- 小仓位试错
- 设置最大单笔风险（2-3%）
- 完善错误处理

### 2. 策略风险

- 震荡市可能频繁止损
- 趋势反转可能来不及出场
- 黑天鹅事件无法预防

**应对**：
- 不在震荡市加仓
- 设置总资金止损线（15%）
- 保持充足现金储备

### 3. 人性风险

- 盈利后过度自信
- 亏损后急于翻本
- 违反交易纪律

**应对**：
- 完全自动化执行
- 定期复盘反思
- 保持谦逊态度

---

## 📞 下一步行动

### 本周（立即开始）

- [ ] 阅读完整文档理解策略逻辑
- [ ] 确认chan.py正常工作
- [ ] 运行`multi_level_strategy_simple.py`示例
- [ ] 理解数据结构和决策流程

### 下周（深入实现）

- [ ] 实现与chan.py的数据对接
- [ ] 完成核心决策逻辑
- [ ] 编写单元测试
- [ ] 初步历史数据验证

### 本月（完整测试）

- [ ] 3个月历史数据回测
- [ ] 优化参数
- [ ] 模拟盘运行
- [ ] 准备小资金实盘

---

## 📚 相关文档

- **核心决策逻辑**：`doc/多级别联立交易策略-核心决策逻辑.md`（600行详细文档）
- **简化实现代码**：`app/services/multi_level_strategy_simple.py`（300行可运行代码）
- **完整实施计划**：`strategy_implementation_plan.md`（详细的每日计划）

---

**最后提醒**：

> 这个策略的核心不是预测市场，而是"跟随确定性"
> 
> - 4H确定了大方向的确定性
> - 1H确定了回调的确定性
> - 30M确定了入场点的确定性
> 
> 当确定性足够时，我们进场
> 当确定性消失时，我们离场
> 
> 就这么简单！

---

**祝交易顺利！** 🚀

