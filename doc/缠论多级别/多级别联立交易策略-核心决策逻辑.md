# 多级别联立自动化交易策略 - 核心决策逻辑

> **前提**：已有chan.py模块可以分析各级别的缠论结构（分型、笔、段、中枢、买卖点）

## 一、策略核心思想

### 1.1 什么是"多级别联立"？

**本质**：用大级别确定大方向的确定性，用小级别寻找低风险入场点

```
错误理解：
多个级别同时出现买点 = 强信号 ❌

正确理解：
大级别处于有利位置 + 小级别给出精确时机 = 高胜率 ✓

核心逻辑：
├─ 日线/4小时：确定主趋势方向（做多还是做空）
├─ 1小时：确定当前处于趋势的哪个阶段（回调？延续？）
└─ 30分钟/15分钟：精确入场时机（具体在哪里买/卖）
```

### 1.2 三级别体系

选择**1小时、4小时、日线**（可调整为30分钟、1小时、4小时）

| 级别 | 作用 | 更新频率 | 关注点 |
|-----|------|---------|--------|
| **日线/4H** | 趋势定调 | 慢 | 当前是上涨趋势还是下跌趋势？ |
| **1小时** | 机会识别 | 中 | 回调到位了吗？可以进场了吗？ |
| **30分钟** | 精确入场 | 快 | 具体的入场价和止损位在哪？ |

---

## 二、可执行的决策流程

### 步骤1：获取各级别的缠论分析结果

**输入**：从chan.py获取各级别的分析结果

```python
# 伪代码：假设已经有这些数据

class MultiLevelData:
    """各级别的缠论分析结果"""
    
    def __init__(self):
        # 每个级别包含的信息
        self.levels = {
            '30m': {
                'fenxings': [...],      # 分型列表
                'bis': [...],           # 笔列表
                'duans': [...],         # 段列表
                'zhongshus': [...],     # 中枢列表
                'bsps': [...],          # 买卖点列表
                'last_price': 42500     # 最新价格
            },
            '1h': {
                'fenxings': [...],
                'bis': [...],
                'duans': [...],
                'zhongshus': [...],
                'bsps': [...],
                'last_price': 42500
            },
            '4h': {
                'fenxings': [...],
                'bis': [...],
                'duans': [...],
                'zhongshus': [...],
                'bsps': [...],
                'last_price': 42500
            }
        }
```

### 步骤2：大级别趋势判断（4小时/日线）

**目标**：确定当前是否处于明确的上涨或下跌趋势

```python
def analyze_major_trend(data_4h):
    """
    分析大级别趋势
    
    返回：
    {
        'direction': 'up' / 'down' / 'neutral',
        'strength': 0-1,
        'trade_permission': {
            'can_long': True/False,
            'can_short': True/False
        }
    }
    """
    
    # 方法1：基于买卖点判断（最简单）
    # ================================
    
    bsps = data_4h['bsps']
    if not bsps:
        return {
            'direction': 'neutral',
            'strength': 0,
            'trade_permission': {'can_long': False, 'can_short': False}
        }
    
    # 查找最近的买卖点
    recent_bsps = bsps[-3:]  # 最近3个买卖点
    
    # 统计买卖点类型
    buy_points = [b for b in recent_bsps if b.is_buy]
    sell_points = [b for b in recent_bsps if not b.is_buy]
    
    # 判断逻辑：
    # 1. 如果最近出现一买/二买/三买 → 上涨趋势
    # 2. 如果最近出现一卖/二卖/三卖 → 下跌趋势
    
    latest_bsp = bsps[-1]
    
    if latest_bsp.is_buy:
        # 最近是买点
        if latest_bsp.type in ['1buy', '2buy']:  # 一买二买：趋势刚开始
            return {
                'direction': 'up',
                'strength': 0.7,
                'trade_permission': {
                    'can_long': True,
                    'can_short': False
                },
                'reason': f'4H出现{latest_bsp.type}，上涨趋势启动'
            }
        elif latest_bsp.type == '3buy':  # 三买：趋势延续
            return {
                'direction': 'up',
                'strength': 0.8,
                'trade_permission': {
                    'can_long': True,
                    'can_short': False
                },
                'reason': f'4H出现三买，上涨趋势延续'
            }
    else:
        # 最近是卖点
        if latest_bsp.type in ['1sell', '2sell']:
            return {
                'direction': 'down',
                'strength': 0.7,
                'trade_permission': {
                    'can_long': False,
                    'can_short': True
                },
                'reason': f'4H出现{latest_bsp.type}，下跌趋势启动'
            }
        elif latest_bsp.type == '3sell':
            return {
                'direction': 'down',
                'strength': 0.8,
                'trade_permission': {
                    'can_long': False,
                    'can_short': True
                },
                'reason': f'4H出现三卖，下跌趋势延续'
            }
    
    # 方法2：基于中枢判断（备选）
    # ================================
    
    # 如果没有明确买卖点，看中枢
    zhongshus = data_4h['zhongshus']
    bis = data_4h['bis']
    
    if not zhongshus or not bis:
        return {
            'direction': 'neutral',
            'strength': 0,
            'trade_permission': {'can_long': False, 'can_short': False}
        }
    
    latest_zs = zhongshus[-1]
    latest_bi = bis[-1]
    
    # 判断：当前价格相对中枢的位置
    current_price = data_4h['last_price']
    
    if current_price > latest_zs.ZG:  # 在中枢上方
        return {
            'direction': 'up',
            'strength': 0.6,
            'trade_permission': {
                'can_long': True,
                'can_short': False
            },
            'reason': '价格在4H中枢上方'
        }
    elif current_price < latest_zs.ZD:  # 在中枢下方
        return {
            'direction': 'down',
            'strength': 0.6,
            'trade_permission': {
                'can_long': False,
                'can_short': True
            },
            'reason': '价格在4H中枢下方'
        }
    else:  # 在中枢内部
        return {
            'direction': 'neutral',
            'strength': 0.3,
            'trade_permission': {
                'can_long': False,
                'can_short': False
            },
            'reason': '价格在4H中枢内震荡'
        }
```

### 步骤3：中级别机会识别（1小时）

**目标**：在允许的方向上，寻找具体的交易机会

```python
def identify_opportunity_1h(data_1h, major_trend):
    """
    识别1小时级别的交易机会
    
    策略：
    1. 如果大级别允许做多，寻找1H的回调买点
    2. 如果大级别允许做空，寻找1H的反弹卖点
    """
    
    opportunities = []
    
    bsps_1h = data_1h['bsps']
    if not bsps_1h:
        return opportunities
    
    latest_bsp_1h = bsps_1h[-1]
    
    # 场景1：大级别允许做多
    # ====================
    if major_trend['trade_permission']['can_long']:
        
        # 子场景1.1：1H出现买点（最直接）
        if latest_bsp_1h.is_buy:
            opportunities.append({
                'type': 'long',
                'trigger': f'1H买点: {latest_bsp_1h.type}',
                'confidence': 0.7 if latest_bsp_1h.type == '2buy' else 0.8,
                'entry_reference': latest_bsp_1h.klu.close,
                'stop_reference': latest_bsp_1h.klu.low * 0.98
            })
        
        # 子场景1.2：1H回调到中枢上沿（次优）
        zhongshus_1h = data_1h['zhongshus']
        if zhongshus_1h:
            latest_zs_1h = zhongshus_1h[-1]
            current_price = data_1h['last_price']
            
            # 如果价格回调到中枢上沿附近（±3%范围）
            zs_top = latest_zs_1h.ZG
            if abs(current_price - zs_top) / zs_top < 0.03:
                opportunities.append({
                    'type': 'long',
                    'trigger': '1H回调至中枢上沿',
                    'confidence': 0.6,
                    'entry_reference': zs_top,
                    'stop_reference': latest_zs_1h.ZD
                })
    
    # 场景2：大级别允许做空
    # ====================
    elif major_trend['trade_permission']['can_short']:
        
        # 子场景2.1：1H出现卖点
        if not latest_bsp_1h.is_buy:
            opportunities.append({
                'type': 'short',
                'trigger': f'1H卖点: {latest_bsp_1h.type}',
                'confidence': 0.7 if latest_bsp_1h.type == '2sell' else 0.8,
                'entry_reference': latest_bsp_1h.klu.close,
                'stop_reference': latest_bsp_1h.klu.high * 1.02
            })
        
        # 子场景2.2：1H反弹到中枢下沿
        zhongshus_1h = data_1h['zhongshus']
        if zhongshus_1h:
            latest_zs_1h = zhongshus_1h[-1]
            current_price = data_1h['last_price']
            
            zs_bottom = latest_zs_1h.ZD
            if abs(current_price - zs_bottom) / zs_bottom < 0.03:
                opportunities.append({
                    'type': 'short',
                    'trigger': '1H反弹至中枢下沿',
                    'confidence': 0.6,
                    'entry_reference': zs_bottom,
                    'stop_reference': latest_zs_1h.ZG
                })
    
    return opportunities
```

### 步骤4：小级别精确入场（30分钟）

**目标**：确定精确的入场价格和止损位置

```python
def determine_entry_30m(data_30m, opportunity_1h):
    """
    基于30分钟级别确定精确入场点
    
    策略：
    1. 等待30M出现确认信号（分型/买卖点）
    2. 用30M的结构设置止损
    """
    
    if not opportunity_1h:
        return None
    
    # 方法1：等待30M买卖点确认（最可靠）
    # ===================================
    
    bsps_30m = data_30m['bsps']
    if bsps_30m:
        latest_bsp_30m = bsps_30m[-1]
        
        # 如果1H是做多机会，等待30M买点
        if opportunity_1h['type'] == 'long' and latest_bsp_30m.is_buy:
            return {
                'action': 'open_long',
                'entry_price': latest_bsp_30m.klu.close,
                'stop_loss': latest_bsp_30m.klu.low * 0.98,
                'confidence': opportunity_1h['confidence'] * 0.9,
                'reason': f"1H机会:{opportunity_1h['trigger']} + 30M买点:{latest_bsp_30m.type}"
            }
        
        # 如果1H是做空机会，等待30M卖点
        elif opportunity_1h['type'] == 'short' and not latest_bsp_30m.is_buy:
            return {
                'action': 'open_short',
                'entry_price': latest_bsp_30m.klu.close,
                'stop_loss': latest_bsp_30m.klu.high * 1.02,
                'confidence': opportunity_1h['confidence'] * 0.9,
                'reason': f"1H机会:{opportunity_1h['trigger']} + 30M卖点:{latest_bsp_30m.type}"
            }
    
    # 方法2：等待30M分型确认（次优）
    # ===================================
    
    fenxings_30m = data_30m['fenxings']
    if fenxings_30m:
        latest_fx_30m = fenxings_30m[-1]
        
        if opportunity_1h['type'] == 'long' and latest_fx_30m.type == 'bottom':
            return {
                'action': 'open_long',
                'entry_price': latest_fx_30m.price * 1.001,  # 略高于分型
                'stop_loss': latest_fx_30m.price * 0.98,
                'confidence': opportunity_1h['confidence'] * 0.8,
                'reason': f"1H机会:{opportunity_1h['trigger']} + 30M底分型"
            }
        
        elif opportunity_1h['type'] == 'short' and latest_fx_30m.type == 'top':
            return {
                'action': 'open_short',
                'entry_price': latest_fx_30m.price * 0.999,
                'stop_loss': latest_fx_30m.price * 1.02,
                'confidence': opportunity_1h['confidence'] * 0.8,
                'reason': f"1H机会:{opportunity_1h['trigger']} + 30M顶分型"
            }
    
    # 方法3：如果没有明确信号，返回观望
    return None
```

### 步骤5：仓位管理

**目标**：根据信号质量和风险动态调整仓位

```python
def calculate_position_size(entry_signal, account_equity=10000, base_risk_pct=0.02):
    """
    计算开仓大小
    
    核心公式：
    position = (账户净值 × 风险比例 × 信号系数) / 止损距离
    
    信号系数：基于置信度调整
    - 高置信度(>0.8): 1.5倍
    - 中置信度(0.6-0.8): 1.0倍
    - 低置信度(<0.6): 0.5倍
    """
    
    entry = entry_signal['entry_price']
    stop = entry_signal['stop_loss']
    confidence = entry_signal['confidence']
    
    # 止损距离（百分比）
    stop_distance_pct = abs(entry - stop) / entry
    
    # 信号系数
    if confidence >= 0.8:
        signal_coef = 1.5
    elif confidence >= 0.6:
        signal_coef = 1.0
    else:
        signal_coef = 0.5
    
    # 风险金额
    risk_amount = account_equity * base_risk_pct * signal_coef
    
    # 仓位价值
    position_value = risk_amount / stop_distance_pct
    
    # 限制：单笔最大30%仓位
    max_position_value = account_equity * 0.30
    position_value = min(position_value, max_position_value)
    
    # 转换为数量（假设是BTC/USDT）
    position_amount = position_value / entry
    
    return {
        'amount': position_amount,
        'value': position_value,
        'risk_amount': risk_amount,
        'risk_pct': risk_amount / account_equity,
        'signal_coef': signal_coef
    }
```

### 步骤6：持仓管理与出场

**目标**：根据结构破坏动态调整持仓

```python
def manage_position(position, multi_level_data):
    """
    持仓管理
    
    出场规则：
    1. 30M笔破坏 → 减仓50%，移动止损至保本
    2. 1H笔破坏 → 全部平仓
    3. 4H趋势反转 → 立即平仓
    """
    
    actions = []
    
    data_30m = multi_level_data['30m']
    data_1h = multi_level_data['1h']
    data_4h = multi_level_data['4h']
    
    # 检查1：30M笔破坏
    # ==================
    bis_30m = data_30m['bis']
    if bis_30m:
        latest_bi_30m = bis_30m[-1]
        
        # 如果持多单，检查向下笔是否破坏入场结构
        if position['direction'] == 'long':
            if (latest_bi_30m.direction == 'down' and 
                latest_bi_30m.end.price < position['entry_price'] * 0.98):
                
                actions.append({
                    'action': 'reduce_position',
                    'ratio': 0.5,
                    'reason': '30M向下笔破坏入场结构',
                    'new_stop': position['entry_price']  # 移至保本
                })
        
        # 如果持空单，检查向上笔
        elif position['direction'] == 'short':
            if (latest_bi_30m.direction == 'up' and 
                latest_bi_30m.end.price > position['entry_price'] * 1.02):
                
                actions.append({
                    'action': 'reduce_position',
                    'ratio': 0.5,
                    'reason': '30M向上笔破坏入场结构',
                    'new_stop': position['entry_price']
                })
    
    # 检查2：1H笔破坏
    # ==================
    bis_1h = data_1h['bis']
    if bis_1h:
        latest_bi_1h = bis_1h[-1]
        
        if position['direction'] == 'long':
            if (latest_bi_1h.direction == 'down' and 
                latest_bi_1h.end.price < position['entry_price']):
                
                actions.append({
                    'action': 'close_all',
                    'reason': '1H向下笔破坏，趋势结束'
                })
        
        elif position['direction'] == 'short':
            if (latest_bi_1h.direction == 'up' and 
                latest_bi_1h.end.price > position['entry_price']):
                
                actions.append({
                    'action': 'close_all',
                    'reason': '1H向上笔破坏，趋势结束'
                })
    
    # 检查3：4H趋势反转
    # ==================
    trend_4h = analyze_major_trend(data_4h)
    
    if position['direction'] == 'long':
        if trend_4h['direction'] == 'down':
            actions.append({
                'action': 'emergency_close',
                'reason': '4H趋势反转为下跌'
            })
    
    elif position['direction'] == 'short':
        if trend_4h['direction'] == 'up':
            actions.append({
                'action': 'emergency_close',
                'reason': '4H趋势反转为上涨'
            })
    
    # 检查4：止盈机会
    # ==================
    bsps_1h = data_1h['bsps']
    if bsps_1h:
        latest_bsp_1h = bsps_1h[-1]
        
        # 如果出现反向买卖点，考虑止盈
        if position['direction'] == 'long' and not latest_bsp_1h.is_buy:
            # 出现卖点，获利了结
            actions.append({
                'action': 'take_profit',
                'ratio': 0.7,  # 减仓70%
                'reason': f'1H出现{latest_bsp_1h.type}，部分止盈'
            })
        
        elif position['direction'] == 'short' and latest_bsp_1h.is_buy:
            actions.append({
                'action': 'take_profit',
                'ratio': 0.7,
                'reason': f'1H出现{latest_bsp_1h.type}，部分止盈'
            })
    
    return actions
```

---

## 三、完整交易流程（主控制器）

```python
class MultiLevelTradingStrategy:
    """多级别联立交易策略主控制器"""
    
    def __init__(self, symbol="BTC/USDT", equity=10000):
        self.symbol = symbol
        self.equity = equity
        self.position = None  # 当前持仓
        
        # 配置参数
        self.config = {
            'major_level': '4h',      # 主趋势级别
            'operate_level': '1h',    # 操作级别
            'entry_level': '30m',     # 入场级别
            'base_risk_pct': 0.02,    # 基础风险2%
        }
    
    def run(self, multi_level_data):
        """
        执行一次完整分析
        
        参数：
        multi_level_data: {
            '30m': {缠论分析结果},
            '1h': {缠论分析结果},
            '4h': {缠论分析结果}
        }
        """
        
        print(f"\n{'='*60}")
        print(f"多级别联立分析 - {datetime.now()}")
        print(f"{'='*60}\n")
        
        # 步骤1：大级别趋势判断
        trend_4h = analyze_major_trend(multi_level_data['4h'])
        
        print(f"[4H趋势分析]")
        print(f"  方向: {trend_4h['direction']}")
        print(f"  强度: {trend_4h['strength']:.2f}")
        print(f"  允许做多: {trend_4h['trade_permission']['can_long']}")
        print(f"  允许做空: {trend_4h['trade_permission']['can_short']}")
        print(f"  理由: {trend_4h.get('reason', 'N/A')}\n")
        
        # 如果有持仓，优先处理
        if self.position:
            self._manage_existing_position(multi_level_data)
            return
        
        # 步骤2：寻找交易机会
        opportunities = identify_opportunity_1h(
            multi_level_data['1h'],
            trend_4h
        )
        
        if not opportunities:
            print("[1H机会识别] 暂无符合条件的交易机会\n")
            return
        
        print(f"[1H机会识别] 发现{len(opportunities)}个潜在机会")
        for opp in opportunities:
            print(f"  - {opp['trigger']} (置信度: {opp['confidence']:.2f})")
        print()
        
        # 步骤3：精确入场判断
        best_opportunity = max(opportunities, key=lambda x: x['confidence'])
        
        entry_signal = determine_entry_30m(
            multi_level_data['30m'],
            best_opportunity
        )
        
        if not entry_signal:
            print("[30M入场判断] 等待30M确认信号\n")
            return
        
        print(f"[30M入场判断] 入场信号确认!")
        print(f"  操作: {entry_signal['action']}")
        print(f"  入场价: {entry_signal['entry_price']:.2f}")
        print(f"  止损价: {entry_signal['stop_loss']:.2f}")
        print(f"  置信度: {entry_signal['confidence']:.2f}")
        print(f"  理由: {entry_signal['reason']}\n")
        
        # 步骤4：计算仓位
        position_info = calculate_position_size(
            entry_signal,
            self.equity,
            self.config['base_risk_pct']
        )
        
        print(f"[仓位计算]")
        print(f"  开仓数量: {position_info['amount']:.4f}")
        print(f"  仓位价值: ${position_info['value']:.2f}")
        print(f"  风险金额: ${position_info['risk_amount']:.2f}")
        print(f"  风险比例: {position_info['risk_pct']*100:.2f}%")
        print(f"  信号系数: {position_info['signal_coef']:.2f}\n")
        
        # 步骤5：执行开仓
        self._open_position(entry_signal, position_info)
    
    def _open_position(self, entry_signal, position_info):
        """开仓"""
        self.position = {
            'direction': 'long' if 'long' in entry_signal['action'] else 'short',
            'entry_price': entry_signal['entry_price'],
            'stop_loss': entry_signal['stop_loss'],
            'amount': position_info['amount'],
            'value': position_info['value'],
            'open_time': datetime.now(),
            'reason': entry_signal['reason']
        }
        
        print(f"✅ 开仓成功!")
        print(f"  方向: {self.position['direction']}")
        print(f"  数量: {self.position['amount']:.4f}")
        print(f"  入场价: {self.position['entry_price']:.2f}\n")
    
    def _manage_existing_position(self, multi_level_data):
        """管理现有持仓"""
        print(f"[持仓管理]")
        print(f"  方向: {self.position['direction']}")
        print(f"  入场价: {self.position['entry_price']:.2f}")
        print(f"  当前价: {multi_level_data['30m']['last_price']:.2f}\n")
        
        # 检查出场条件
        actions = manage_position(self.position, multi_level_data)
        
        if not actions:
            print("  持仓正常，继续持有\n")
            return
        
        # 执行出场动作
        for action in actions:
            print(f"  触发动作: {action['action']}")
            print(f"  理由: {action['reason']}\n")
            
            if action['action'] in ['close_all', 'emergency_close']:
                self.position = None
                print("  ✅ 已全部平仓\n")
                break
            
            elif action['action'] == 'reduce_position':
                self.position['amount'] *= (1 - action['ratio'])
                self.position['stop_loss'] = action.get('new_stop', 
                                                        self.position['stop_loss'])
                print(f"  ✅ 已减仓{action['ratio']*100:.0f}%\n")


# 使用示例
if __name__ == '__main__':
    
    # 创建策略实例
    strategy = MultiLevelTradingStrategy(
        symbol="BTC/USDT",
        equity=10000
    )
    
    # 假设从chan.py获取的多级别数据
    multi_level_data = {
        '30m': {
            'fenxings': [...],
            'bis': [...],
            'bsps': [...],
            'last_price': 42500
        },
        '1h': {
            'fenxings': [...],
            'bis': [...],
            'zhongshus': [...],
            'bsps': [...],
            'last_price': 42500
        },
        '4h': {
            'bis': [...],
            'zhongshus': [...],
            'bsps': [...],
            'last_price': 42500
        }
    }
    
    # 运行策略
    strategy.run(multi_level_data)
```

---

## 四、与chan.py的集成方案

```python
# integration_example.py

from Chan import CChan
from ChanConfig import CChanConfig
from Common.CEnum import KL_TYPE

class ChanMultiLevelIntegration:
    """Chan.py多级别集成"""
    
    def __init__(self, symbol, begin_time, end_time):
        self.symbol = symbol
        
        # 创建三个级别的Chan实例
        self.chans = {
            '30m': self._create_chan(KL_TYPE.K_30M, begin_time, end_time),
            '1h': self._create_chan(KL_TYPE.K_60M, begin_time, end_time),
            '4h': self._create_chan(KL_TYPE.K_4H, begin_time, end_time)
        }
        
        # 创建交易策略
        self.strategy = MultiLevelTradingStrategy(symbol)
    
    def _create_chan(self, kl_type, begin_time, end_time):
        """创建Chan实例"""
        config = CChanConfig({
            "trigger_step": False,
            "bi_strict": True,
            "seg_algo": "chan",
            "divergence_rate": 0.8,
        })
        
        return CChan(
            code=self.symbol,
            begin_time=begin_time,
            end_time=end_time,
            data_src=DATA_SRC.CCXT,
            lv_list=[kl_type],
            config=config
        )
    
    def get_multi_level_data(self):
        """从各级别Chan中提取所需数据"""
        data = {}
        
        for level, chan in self.chans.items():
            # 获取最新的缠论结构
            if not chan or len(chan) == 0:
                continue
            
            latest_klu_list = chan[-1]
            
            data[level] = {
                'fenxings': self._extract_fenxings(latest_klu_list),
                'bis': self._extract_bis(latest_klu_list),
                'duans': self._extract_duans(latest_klu_list),
                'zhongshus': self._extract_zhongshus(latest_klu_list),
                'bsps': self._extract_bsps(latest_klu_list),
                'last_price': latest_klu_list[-1].close if latest_klu_list else 0
            }
        
        return data
    
    def _extract_fenxings(self, klu_list):
        """提取分型"""
        return klu_list.fx_list if hasattr(klu_list, 'fx_list') else []
    
    def _extract_bis(self, klu_list):
        """提取笔"""
        return klu_list.bi_list if hasattr(klu_list, 'bi_list') else []
    
    def _extract_duans(self, klu_list):
        """提取段"""
        if hasattr(klu_list, 'seg_list'):
            return klu_list.seg_list
        return []
    
    def _extract_zhongshus(self, klu_list):
        """提取中枢"""
        if hasattr(klu_list, 'zs_list'):
            return klu_list.zs_list
        return []
    
    def _extract_bsps(self, klu_list):
        """提取买卖点"""
        return klu_list.bs_point_lst if hasattr(klu_list, 'bs_point_lst') else []
    
    def run(self):
        """运行策略"""
        # 获取多级别数据
        multi_level_data = self.get_multi_level_data()
        
        # 执行策略
        self.strategy.run(multi_level_data)


# 使用
if __name__ == '__main__':
    integration = ChanMultiLevelIntegration(
        symbol="BTC/USDT",
        begin_time="2024-01-01",
        end_time=None
    )
    
    integration.run()
```

---

## 五、关键总结

### 核心决策树

```
┌─ 4H买卖点分析 ──→ 确定方向(多/空/观望)
│
├─ 1H机会识别 ──→ 寻找回调/反弹点
│
├─ 30M入场确认 ──→ 精确入场价+止损
│
├─ 仓位计算 ──→ 根据置信度调整
│
└─ 持仓管理 ──→ 30M/1H/4H分级出场
```

### 优势

1. **逻辑清晰**：每个级别职责明确
2. **易于实现**：直接使用chan.py的输出
3. **风险可控**：多级别确认+分级止损
4. **自动化友好**：规则明确，无主观判断

### 预期表现

- **信号频率**：周2-5次
- **胜率目标**：60-70%
- **盈亏比**：>2:1
- **最大回撤**：<15%

这个方案直接基于chan.py的输出，不需要重新实现缠论元素识别，只专注于多级别决策逻辑！

