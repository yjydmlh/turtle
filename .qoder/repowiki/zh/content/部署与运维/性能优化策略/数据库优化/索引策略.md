# 索引策略

<cite>
**本文档引用的文件**  
- [database_optimization.sql](file://database_optimization.sql)
- [app/models/kline.py](file://app/models/kline.py)
- [app/services/kline_aggregator.py](file://app/services/kline_aggregator.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心索引设计原理](#核心索引设计原理)
3. [索引字段与模型映射](#索引字段与模型映射)
4. [复合索引优化时间范围查询](#复合索引优化时间范围查询)
5. [索引性能验证方法](#索引性能验证方法)
6. [维护建议](#维护建议)

## 引言
本文档旨在详细阐述交易系统中针对 `btc_usdt` 和 `eth_usdt` 表所设计的数据库索引策略。基于 `database_optimization.sql` 中定义的索引语句以及 `app/models/kline.py` 中的数据模型，深入分析三个核心索引的设计动机与性能优势：`idx_btc_usdt_open_time`、`idx_btc_usdt_timestamp` 和 `idx_btc_usdt_time_range`。通过结合实际业务查询场景，说明索引选择标准，并提供性能验证手段。

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L1-L37)
- [app/models/kline.py](file://app/models/kline.py#L1-L37)

## 核心索引设计原理

### 按开盘时间倒序索引（idx_btc_usdt_open_time）
该索引在 `open_time` 字段上创建，并使用 `DESC` 排序方式，主要服务于高频查询最新K线数据的场景。例如，在实时行情展示或聚合计算中，通常需要获取最近N条K线记录。

由于数据按时间递增写入，最新的数据具有最高的 `open_time` 值。通过 `DESC` 排序，数据库可以快速定位到最新记录，无需扫描整个表或进行额外排序操作，从而显著提升查询效率。

```sql
CREATE INDEX IF NOT EXISTS idx_btc_usdt_open_time ON btc_usdt(open_time DESC);
```

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L5)
- [app/models/kline.py](file://app/models/kline.py#L8)

### 时间戳字段索引（idx_btc_usdt_timestamp）
`timestamp` 字段存储毫秒级时间戳，常用于与外部系统对接或精确时间点查询。为该字段建立索引可加速基于时间戳的等值或范围查询，尤其适用于API接口中以时间戳作为参数的请求。

该索引支持高效检索特定时间点附近的K线数据，是时间维度查询的重要支撑。

```sql
CREATE INDEX IF NOT EXISTS idx_btc_usdt_timestamp ON btc_usdt(timestamp);
```

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L6)
- [app/models/kline.py](file://app/models/kline.py#L7)

## 索引字段与模型映射
所有索引字段均在 `Kline` 基类及其子类中有明确定义。`open_time` 为 `DateTime` 类型，表示K线开始时间；`timestamp` 为 `BigInteger` 类型，存储毫秒级时间戳。这些字段在模型中被标记为非空且参与业务逻辑核心查询，因此是理想的索引候选字段。

索引设计与数据访问模式高度匹配。例如，`kline_aggregator.py` 中的聚合逻辑频繁使用 `open_time` 进行时间范围过滤和排序，这正是 `idx_btc_usdt_open_time` 被设计为倒序索引的根本原因。

**Section sources**
- [app/models/kline.py](file://app/models/kline.py#L7-L8)
- [app/services/kline_aggregator.py](file://app/services/kline_aggregator.py#L50-L55)

## 复合索引优化时间范围查询
复合索引 `idx_btc_usdt_time_range` 建立在 `(open_time, close_time)` 两个字段之上，专门用于优化时间范围查询。当用户请求某一时段内的所有K线数据时（如“获取今天的所有1小时K线”），数据库可利用此复合索引快速定位起始和结束时间范围内的记录。

复合索引的优势在于：
- 减少多字段查询时的索引合并开销
- 提高覆盖索引的可能性，避免回表查询
- 支持更复杂的范围条件优化

```sql
CREATE INDEX IF NOT EXISTS idx_btc_usdt_time_range ON btc_usdt(open_time, close_time);
```

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L7)
- [app/models/kline.py](file://app/models/kline.py#L8-L9)

## 索引性能验证方法
为确保索引有效性，应使用数据库提供的执行计划分析工具进行验证。推荐使用 `EXPLAIN ANALYZE` 命令来评估查询性能。

例如，执行以下命令可查看基于 `open_time` 的查询是否命中索引：

```sql
EXPLAIN ANALYZE SELECT * FROM btc_usdt WHERE open_time > '2024-01-01' ORDER BY open_time DESC LIMIT 100;
```

预期结果应显示使用了 `idx_btc_usdt_open_time` 索引，并且排序操作未产生额外开销（即 `ORDER BY` 利用索引顺序完成）。

此外，定期运行 `ANALYZE` 命令更新表统计信息，有助于查询优化器做出更优的执行计划决策。

```sql
ANALYZE btc_usdt;
```

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L14)
- [app/services/kline_aggregator.py](file://app/services/kline_aggregator.py#L50-L55)

## 维护建议
为保持索引性能稳定，建议实施以下定期维护任务：
- 定期执行 `VACUUM ANALYZE` 以清理死元组并更新统计信息
- 监控索引大小与查询性能，识别潜在的冗余或低效索引
- 在数据批量导入后手动执行 `ANALYZE`，确保统计信息及时更新

注释中提供的配置优化建议（如 `random_page_cost`、`effective_io_concurrency`）也可根据实际硬件环境进行调整，以进一步提升查询性能。

**Section sources**
- [database_optimization.sql](file://database_optimization.sql#L34-L36)